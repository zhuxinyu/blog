# 【译】贪心算法基础

原文地址：https://www.hackerearth.com/zh/practice/algorithms/greedy/basics-of-greedy-algorithms/tutorial/

**介绍**

算法设计中没有一个‘银子弹’能解决所有计算问题。不同的问题需要用不同的技法解决。一个好的开发者会基于问题的类型使用这些技法。一些常用的技法：

 	1. 分而治之
 	2. 随机算法
 	3. 贪心算法（这不是一个算法，这是一种技法(译者注：思想)）
 	4. 动态编程

**什么是贪心算法 ?**

贪心算法，就像名字建议的, **总是选择当时看起来最好的**。这意味着希望局部最优选择能得到全局最优解决办法。

如何选择才是最优 ？

假设你有一个在给定点需要优化的目标函数（或者达到最大限度或者最小限度）。贪心算法在每一步的贪心选择使得确保目标函数最优化。贪心算法**从不回头推翻决定**，它只有一个目标就是计算出最优解。

<br>

贪心算法的一些优势和劣势：

1. 对于开发者**实现一个贪心算法**很容易（或者甚至多重贪心算法）
2. **分析运行中的贪心算法通常更容易**相比于其他技法（例如分而治之）。关于分治法，技法效率是快还是慢不是很清晰。这是因为在递归的每个级别上，子问题的规模变小了，子问题的数量增加了。
3. 关于贪心算法困难的部分**你必须更努力理解正确性问题**。即使有正确算法，也很难证明它为什么是正确的。证明贪心算法的正确性更多的是一门艺术而不是科学。它需要很多创造力。

**笔记**:很多贪心算法**不**是正确的。后文会举例说明。

**C.如何创建一个贪心算法 ？**

作为一个非常忙碌的人，你正好有**T**时间去做一些有意思的事，你想做最大限度的这样的事情.

你有一个整数数组**A**,每个元素表示完成一件事的时间。你想计算在有限的时间里能完成的事的最大数。

这是一个简单的贪心算法问题。在每一个迭代，你必须贪婪地选择能用最小时间完成的事情通过维护两个变量**currentTime**和**numberOfThings**. 为了完成算法，你必须：

1. 对数组**A**进行非递减排序。
2. 逐步选择每个待办事项。
3. 将待办事项的时间加到**currentTime**.
4. 对**numberOfThins**加一

重复直到**currentTime**小于或等于**T**。

Let **A** = **{5, 3, 4, 2, 1}** and **T** = **6**

之后排序， **A** = **{1, 2, 3, 4, 5}**

之后第一步操作：

- **currentTime** = 1
- **numberOfThings** = 1

之后第二步操作：

- **currentTime** 是 1 + 2 = 3
- **numberOfThings** = 2

之后第三步操作：

- **currentTime** 是 3 + 3 = 6
- **numberOfThings** = 3

之后第四步操作， **currentTime** 是 4 + 6 = 10，比**T**大。因此，答案是3.

**具体实现**

```c++
 #include <iostream>
    #include <algorithm>

    using namespace std;
    const int MAX = 105;
    int A[MAX];

    int main()
    {
        int T, N, numberOfThings = 0, currentTime = 0;
        cin >> N >> T;
        for(int i = 0;i < N;++i)
            cin >> A[i];
        sort(A, A + N);
        for(int i = 0;i < N;++i)
        {
            currentTime += A[i];
            if(currentTime > T)
                break;
            numberOfThings++;
        }
        cout << numberOfThings << endl;
        return 0;
    }
```

这个例子很简单，当你读到问题的时候，很明显你可以应用贪心算法.

考虑一个更难点的问题-**日程**问题

你有以下内容：

- 列出你今天需要完成的所有任务
- 每个任务需要的时间
- 每个工作的优先级（或者权重）

你需要决定你要完成的任务按照什么样的排序以获得最优解。

为了解决这个问题你需要分析你的输入。在这个问题，你的输入如下：

- 整数 N 存储你想要完成的任务个数
- 列表(lists) P:优先级（或者权重）
- 列表(list) T: 完成一个任务需要的时间

为了理解要优化的标准，您必须确定完成每个任务所需的总时间.

**C(j) = T[1] + T[2] + .... + T[j] where 1 <= j <= N**

这是因**第j个**任务要等待直到(j-1)个任务完成之后完成需要T[j]时间。

举个🌰，如果 T = {1， 2， 3}, 实现时间就会是：

- C(1) = T[1] = 1
- C(2) = T[1] + T[2] = 1 + 2 = 3
- C(3) = T[1] + T[2] + T[3] = 1 + 2 + 3 = 6

很明显你想要完成的时间要尽可能少。但这并不简单。

在给定的序列中，在开始时排队的作业完成时间较短，在结束时排队的作业完成时间较长。

什么是实现任务的优化方法？

这取决于你的目标函数。这有一些目标函数在"日程"问题，你的目标函数**F**是**完成时间的加权和**。

**F = P[1] * C(1) + P[2] * C(2) + …… + P[N] * C(N)**

这个目标函数必须最小化。

***特殊情况***

考虑一些比较直观的特殊情况关于最优的做法是什么。看看这些特殊的情况，你会发现一些自然的贪婪算法，然后你会发现如何将这些算法缩小到一个候选，你会证明是正确的。

以下有两种特殊情况：

1. 如果完成不同任务需要相同的时间。**T[i] = T[j] where 1<= i, j <= N**，但他们有不同的权重会如何安排工作？
2. 如果不同的工作权重相同。**P[i] = P[j] where 1 <= i, j <= N**，但他们有不同的时长会如何安排工作？

如果完成不同任务需要相同的时间，你应该首先考虑优先级高的任务

**情况一**

考虑你需要最小化目标函数，假设完成不同任务需要的时间是**t**.

T[i] = t where 1 <= i <= N

不管用什么序列，每个任务的完成时间都会如下：

C(1) = T[1] = t

C(2) = T[1] + T[2] = 2 * t

C(3) = T[1] + T[2] + T[3] = 3 * t

...

C(N) = N * t

为了使目标函数尽可能小，必须将最高优先级与最短的完成时间相关联.

**情况二**

在第二种情况，如果不同任务的优先级相同，你必须优先选择用时最少的任务去完成。假设不同任务的优先级是**p**.

F = P[1] * C(1) + P[2] * C(2) + …… + P[N] * C(N)

F = p * C(1) + p * C(2) + …… + p * C(N)

F = p * (C(1) + C(2) + …… + C(N))

为了得到F的最小值，你必须获得(C(1) + C(2) + …… + C(N))的最小值，就是你开始工作完成需要的最短时间。

这里有两条规则。优先考虑哪些任务：

- 高优先级
- 完成需要更少的时间

下一步是跳出特殊情况，回到普通情况。在普通情况，优先级和花费时间每个任务都不一样。

如果你有两个任务并且两条规则给你相同的建议，任务有更高的优先级并且花费时间更少就是很清晰的必须优先完成的任务。但是如果两条规则给你的建议冲突了怎么办？假如你有一对任务其中一个有高优先级，但比另一个任务需要更长的时间去完成？（P[i] > P[j] 但是 T[i] > T[j]）.你该先完成哪个？

你能不能将这两个参数（时间和优先级）合成一个简单的分数， 这样你就可以通过分数排序任务，总能得到最优解。

记住两条规则。

1. 偏爱好优先级就会导致更高的优先级主导更高的分数。
2. 偏爱花费更少的时间去完成任务就会让多时间需求非-递增排序分数。

你可以用简单的计算函数，输入两个数（优先级和时间）返回一个简单的数（分数）输出当遇到这两种属性。(这样的函数有无穷多个。)

让我们看两个有这种属性的最简单的函数：

- 算法 #1：排序任务通过**降序值(P[i] -  T[i])**
- 算法 #2：排序任务通过**降序值(P[i] / T[i])**

为了简单起见，我们假设它们之间没有联系。

现在你有两个算法并且至少它们其中之一是错误的。排除做错事的算法。

T = {5, 2} and P = {3, 1}

通过算法#1(P[1] - T[1]) < (P[2] - T[2]), 因此，第二个任务应该先完成，并且你的目标函数会变成这样：

F = P[1] * C(1) + P[2] * C(2) = 1 * 2 + 3 * 7 = 23

通过算法#2(P[1]  / T[1]) > (P[2] / T[2]), 因此，第一个任务应该先完成，并且你的目标函数会变成这样：

F = P[1] * C(1) + P[2] * C(2) = 3 * 5 + 1 * 7 = 22

算法#1不能给你最优解，因此，算法#1不是（**总**）正确。

**笔记**：记住贪心算法经常是**错误**的。只因为算法#1是错的，并不代表算法#2是确保正确的。然而，在这种情况下，算法2总是正确的。

因此，返回目标函数最优值的最终算法为:

```C++
  Algorithm (P, T, N)
    {
        let S be an array of pairs ( C++ STL pair ) to store the scores and their indices
        , C be the completion times and F be the objective function
        for i from 1 to N:
            S[i] = ( P[i] / T[i], i )            // Algorithm #2
        sort(S)
        C = 0
        F = 0
        for i from 1 to N:                // Greedily choose the best choice
            C = C + T[S[i].second]
            F = F + P[S[i].second]*C
        return F
    }
```

**时间复杂度**你有两个循环，花费O(N)时间, 一个排序方法，花费O(N * logN)时间。 因此，时间复杂度总共是 O(2 * N + N + logN) = **O(N + logN)**

**正确性的证明** （译者略，反证法）

