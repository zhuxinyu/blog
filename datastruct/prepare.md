<h1>绪论</h1> (所有英文部分不翻译，只是自我理解)

1. To measure is to know. If you can not measure it , you can not improve it .  - Lord Kelvin (对任何事物都要有衡量标准，否则就无法知道如何提高，是否提高。)

2. 算法分析 ： 正确性 + 成本 （运行时间 + 所需空间）

3. 问题实例的规模往往是决定计算成本的主要因素

4. 规模接近，计算成本也接近； 规模扩大，计算成本亦上升

5. 特定算法不同实例的复杂度只关注成本最高（情况最坏）者

6. 特定问题不同算法的优劣通常在理想平台上抽象评判，忽略规模，类型，操作人，语言，编译器，体系结构，操作系统等。

7. turing machine 计算原理： 一条Tape一次均匀地划分为单元格，每个格子有默认字符(Alphabet)，有一个head指针可存储一个状态，且可向左或向右移动，每次移动一位。 例: （q, c; d, L/R, p）：指令翻译：若当前状态q且当前字符为c，则将当前字符改写为d，head指针转向左/右临格；转入'p'状态，一但转入特定状态'h', 则停机。

8. random access machine 计算原理: 寄存器顺序编号，理论上总数没有限制，每次一步基本操作（减法，减法，赋值，查询/判断）,每一基本操作仅需常数时间（循环及子程序本身非基本操作）。例：向下取整得除法计算

   算法： 反复地从R[0] = 1 + c 中减去R[1] = d 统计在下溢之前，所做减法的次数x 

   13 / 5 = ？ ; c = 13 d = 5

   | 0    | R[3] <- 1 //increment                 |
   | ---- | ------------------------------------- |
   | 1    | R[0] <- R[0] + R[3] //c++             |
   | 2    | R[0] <- R[0] - R[1] //c -= d          |
   | 3    | R[2] <- R[2] + R[3] // x++            |
   | 4    | IF R[0] > 0 GOTO 2 // if c > 0 goto 2 |
   | 5    | R[0] <- R[2] - R[3] // else x-- and   |
   | 6    | STOP // return R[0] = x = [c/d]       |



   | Step |  IR  | R[0] | R[1] | R[2] | R[3] |
   | :--: | :--: | :--: | :--: | :--: | :--: |
   |  0   |  0   |  12  |  5   |  0   |  0   |
   |  1   |  1   |  ^   |  ^   |  ^   |  1   |
   |  2   |  2   |  13  |  ^   |  ^   |  ^   |
   |  3   |  3   |  8   |  ^   |  ^   |  ^   |
   |  4   |  4   |  ^   |  ^   |  1   |  ^   |
   |  5   |  2   |  ^   |  ^   |  ^   |  ^   |
   |  6   |  3   |  3   |  ^   |  ^   |  ^   |
   |  7   |  4   |  ^   |  ^   |  2   |  ^   |
   |  8   |  2   |  ^   |  ^   |  ^   |  ^   |
   |  9   |  3   |  0   |  ^   |  ^   |  ^   |
   |  10  |  4   |  ^   |  ^   |  3   |  ^   |
   |  11  |  5   |  ^   |  ^   |  ^   |  ^   |
   |  12  |  6   |  2   |  ^   |  ^   |  ^   |
