<h1>绪论</h1> (所有英文部分不翻译，只是自我理解)

1. Computer science should be called computing science, for the same reason why surgery is not called knife science. E. Dijkstra (计算机科学的核心是计算科学，强调数据结构和算法的重要性)

2. 绳索计算机： 一段绳索，取12段等长打结，首尾相连，其中一条向一个方向拉直，取四个节点处固定，将剩余绳索在左3右5处极力拉伸，直到每一段都伸直，即形成直角三角形，古埃及人用此方法绘制垂线，带12段等长节点的绳索即为计算机（计算工具）

3. 尺规计算机：任给平面上线段AB（输入）,将其三等分(输出)， 尺规利用圆的半径相等，在一条辅助线（与AB同起点非退化（不重合）的射线）上做三个等分点，<img src="https://github.com/zhuxinyu/blog/blob/master/datastruct/WX20181207-142809%402x.png" width = "440" height = "225" div align=right />

   做最外层等分点与B的连接线，通过其他两个等分点做连接线的平行线，与AB相交于C、D点，B、C、D即为AB的三等分点。

4. 计算：借助某种**工具**，按照一定**规则**，以**明确**而**机械**的形式进行。

5. 计算模型：信息处理工具（例：计算机）

6. 算法： 即在特定计算模型下，旨在解决特定问题的指令序列

7. 算法特性： 有穷性，正确性

8. 好算法：**效率**，**正确**，健壮，可读

9. 各**数据结构**的ADT接口及其不同实现：

   序列（向量，列表，栈，队列），树及搜索树（AVL树，伸展树，红黑树，B-树，kd-树），优先队列（堆），字典（散列表，跳转表），图的算法与应用

10. 构造**有效算法模块**的常用技巧：

  顺序和二分查找，选取与排序，遍历，模式匹配，散列，几何查找

11. 算法设计的**典型策略与模式**：

    迭代、贪心、递归、分治、减治、试探-剪枝-回溯、动态规划

12. **复杂度分析**的基本方法：

    渐进分析与相关记号

    递推关系、递归跟踪

    分摊分析、后向分析

13. To measure is to know. If you can not measure it , you can not improve it .  - Lord Kelvin (对任何事物都要有衡量标准，否则就无法知道如何提高，是否提高。)

14. 算法分析 ： **正确性** + **成本** （运行时间 + 所需空间）

15. 问题实例的**规模**往往是决定计算成本的主要因素

16. 规模接近，计算成本也接近； 规模扩大，计算成本亦上升

17. 特定算法不同实例的复杂度只关注**成本最高**（情况最坏）者

18. 特定问题不同算法的优劣通常在理想平台上抽象评判，忽略规模，类型，操作人，语言，编译器，体系结构，操作系统等。

19. turing machine 计算原理： 一条Tape一次均匀地划分为单元格，每个格子有默认字符(Alphabet)，有一个head指针可存储一个状态，且可向左或向右移动，每次移动一位。 例: （q, c; d, L/R, p）：指令翻译：若当前状态q且当前字符为c，则将当前字符改写为d，head指针转向左/右临格；转入'p'状态，一但转入特定状态'h', 则停机。

20. random access machine 计算原理: 寄存器顺序编号，理论上总数没有限制，每次一步基本操作（减法，减法，赋值，查询/判断）,每一基本操作仅需常数时间（循环及子程序本身非基本操作）。例：向下取整得除法计算

    算法： 反复地从R[0] = 1 + c 中减去R[1] = d 统计在下溢之前，所做减法的次数x 

    13 / 5 = ？ ; c = 13 d = 5

    | 0    | R[3] <- 1 //increment                 |
    | ---- | ------------------------------------- |
    | 1    | R[0] <- R[0] + R[3] //c++             |
    | 2    | R[0] <- R[0] - R[1] //c -= d          |
    | 3    | R[2] <- R[2] + R[3] // x++            |
    | 4    | IF R[0] > 0 GOTO 2 // if c > 0 goto 2 |
    | 5    | R[0] <- R[2] - R[3] // else x-- and   |
    | 6    | STOP // return R[0] = x = [c/d]       |



| Step |  IR  | R[0] | R[1] | R[2] | R[3] |
| :--: | :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  12  |  5   |  0   |  0   |
|  1   |  1   |  ^   |  ^   |  ^   |  1   |
|  2   |  2   |  13  |  ^   |  ^   |  ^   |
|  3   |  3   |  8   |  ^   |  ^   |  ^   |
|  4   |  4   |  ^   |  ^   |  1   |  ^   |
|  5   |  2   |  ^   |  ^   |  ^   |  ^   |
|  6   |  3   |  3   |  ^   |  ^   |  ^   |
|  7   |  4   |  ^   |  ^   |  2   |  ^   |
|  8   |  2   |  ^   |  ^   |  ^   |  ^   |
|  9   |  3   |  0   |  ^   |  ^   |  ^   |
|  10  |  4   |  ^   |  ^   |  3   |  ^   |
|  11  |  5   |  ^   |  ^   |  ^   |  ^   |
|  12  |  6   |  2   |  ^   |  ^   |  ^   |

21. Mathematics is more in need of good notations than of new theorems. - Alan Turing

    好读书不求甚解，每有会意，便欣然忘食 - 陶渊明

    (算法效率的思想跟不求甚解异曲同工，忽略掉小的细节因素，统计主流的影响因素，有一个标记对思想很重要，算法复杂度的标记就为O (最坏情况),Ω (最好情况), Θ(最好最坏组合情况)。

22. 渐进分析：可忽略常数项、低次项

    T(n) = O( f(n) ): iff 存在 c > 0 ，当 n >> 2 后，有 T(n) < c·f(n)

    T(n) = Ω( f(n)): 存在 c > 0, 当 n >> 2 后，有T(n) > c·f(n)

    T(n) = Θ( f(n)): 存在 c<sub>1</sub> > c<sub>2</sub> > 0, 当 n >> 2 后，有c<sub>1</sub>·f(n) > T(n) > c<sub>2</sub>·f(n)

23. 复杂度层次：

    <img src="https://github.com/zhuxinyu/blog/blob/master/datastruct/WX20181207-161533%402x.png" width = "1000" height = "600" div align=left />