<h1>第七部分 算法封装</h1>

> 概要
>
> > - 模板方法 template method
> > - 策略 strategy
> > - 命令 command

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>模板方法</h3>

- **what** : 

  定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变该算法的结构。 

- **how** ：

  在抽象类的一个方法中定义‘标准’算法。在这个方法中调用的基本操作应由子类重载予以实现。

- **why** ：

  1. 需要一次性实现算法的不变部分，并将可变的行为留给子类来实现
  2. 子类的共同行为应被提取出来放在公共类中，以避免代码重复。
  3. 需要控制子类的扩展，可以定义一个在特定点调用hook操作的模板方法。

<br>

---

Tips:

- 模板方法会调用5种类型的操作
  1. 对具体类或客户端类的具体操作
  2. 对抽象类的具体操作
  3. 抽象操作
  4. 工厂方法
  5. hook操作（可选的抽象操作）

<br>

- |                           模板方法                           |                      委托（适配器）                      |
  | :----------------------------------------------------------: | :------------------------------------------------------: |
  | 父类定义一个一般算法，但缺少某些特定、可选的信息或算法，它通过这些缺少的信息或算法起到一个算法‘食谱’的作用 | 委托（适配器）与预先定义好的委托接口一起定义一个特定算法 |
  |                缺少的信息由子类通过继承来提供                |           特定算法由任何对象通过对象组合来提供           |

---

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>策略</h3>

- **what** : 

  定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

- **how** ：

  为所有支持的或相关的算法声明一个共同的接口

- **why** ：

  1. 一个类在其操作中使用多个条件语句来定义许多行为。我们可以把相关的条件分支移到它们自己的策略类中。
  2. 需要算法的各种变体。
  3. 需要避免把复杂的与算法相关的数据结构暴露给客户端

<br>

---

Tips:

- M-V-C中的策略模式:

  ​	模型-视图-控制器模式中，控制器是视图的策略，决定视图对模型数据进行显示的时机和内容。

---

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>命令</h3>

- **what** : 

  将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。命令对象将一个或多个动作绑定到特定的接收器。命令模式消除了作为对象的动作和执行他的接收器之间的绑定。

- **how** ：

  通过把请求封装成对象，客户端可以把它参数化并置入队列或日志中，通过恢复栈和撤销栈实现命令的可撤销操作。

- **why** ：

  1. 想让应用程序支持撤销与恢复
  2. 想要在不同时刻对请求进行指定、排列和执行。
  3. 想记录修改日志，这样在系统故障时，这些修改可在后期重做一遍。
  4. 想让系统支持transaction，transaction封装了对数据的一系列修改，可以建模为命令对象。

<br>

---

Tips:

- 恢复栈和撤销栈原理：（发生于一个 run loop 周期）
   	1. 请求撤销 -> 调用撤销栈顶部的操作对象 -> 撤销完成将此操作对象压入恢复栈
   	2. 请求恢复 -> 调用恢复栈顶部的操作对象 -> 恢复完成将此操作对象压入撤销栈 
- Cocoa中的命令模式：
   	1. NSInvocation对象封装运行时库以向接收器转发执行消息时所需的所有必要信息，如目标对象、方法选择器和方法的参数。因此可以借助NSInvocation实例，使用内部的选择器和其他信息，在任何时候调用接收器。同一个NSInvocation实例可重复滴啊用接收器的同一个方法，或者通过不同的目标和方法签名进行复用。
   	2. NSUndoManger的实例管理自己的撤销和恢复栈。通过使用各种延迟调用转发机制，省去了处理撤销与恢复操作的麻烦。

---

