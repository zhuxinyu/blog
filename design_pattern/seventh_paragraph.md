<h1>第七部分 算法封装</h1>

> 概要
>
> > - 模板方法 template method
> > - 策略 strategy
> > - 命令

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>模板方法</h3>

- **what** : 

  定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变该算法的结构。 

- **how** ：

  在抽象类的一个方法中定义‘标准’算法。在这个方法中调用的基本操作应由子类重载予以实现。

- **why** ：

  1. 需要一次性实现算法的不变部分，并将可变的行为留给子类来实现
  2. 子类的共同行为应被提取出来放在公共类中，以避免代码重复。
  3. 需要控制子类的扩展，可以定义一个在特定点调用hook操作的模板方法。

<br>

---

Tips:

- 模板方法会调用5种类型的操作
  1. 对具体类或客户端类的具体操作
  2. 对抽象类的具体操作
  3. 抽象操作
  4. 工厂方法
  5. hook操作（可选的抽象操作）

<br>

- |                           模板方法                           |                      委托（适配器）                      |
  | :----------------------------------------------------------: | :------------------------------------------------------: |
  | 父类定义一个一般算法，但缺少某些特定、可选的信息或算法，它通过这些缺少的信息或算法起到一个算法‘食谱’的作用 | 委托（适配器）与预先定义好的委托接口一起定义一个特定算法 |
  |                缺少的信息由子类通过继承来提供                |           特定算法由任何对象通过对象组合来提供           |

---

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>策略</h3>

- **what** : 

  定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

- **how** ：

  为所有支持的或相关的算法声明一个共同的接口

- **why** ：

  1. 一个类在其操作中使用多个条件语句来定义许多行为。我们可以把相关的条件分支移到它们自己的策略类中。
  2. 需要算法的各种变体。
  3. 需要避免把复杂的与算法相关的数据结构暴露给客户端

<br>

---

Tips

- M-V-C中的策略模式:

  ​	模型-视图-控制器模式中，控制器是视图的策略，决定视图对模型数据进行显示的时机和内容。

---

<br>

<br>

