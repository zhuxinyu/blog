<h1>第八部分 性能与访问对象</h1>

> 概要
>
> > - 享元 flyweight 
> > - 代理 proxy

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>享元</h3>

- **what** : 

  运用共享技术有效地支持大量细粒度的对象。

- **how** ：

  实现享元模式需要两个关键组件，通常是可共享的享元对象和保存他们的池。某种中央对象维护这个池，并从它返回适当的实例。(工厂是这一角色的理想候选)

- **why** ：

  1. 应用程序使用很多对象
  2. 在内存中保存对象会影响内存性能
  3. 对象的多数特有状态（外在状态）可以放到外部而轻量化
  4. 移除了外在状态之后，可以用较少的共享对象替代原来的那组对象
  5. 应用程序不依赖于对象标识，因为共享对象不能提供唯一的标识

<br>

---

Tips:

- 节省空间的影响因素：
   	1. 通过共享减少的对象总数，越多节省空间越大
   	2. 每个对象中内在状态（即可共享状态）的数量，越多越节省内在开销
   	3. 外在状态是计算出来的还是保存的，外在状态的传递、查找和计算，可能产生运行时的开销，尤其在外在状态原本是作为内在状态来保存的时候。如果有大量内在和外在状态，外在状态又能够计算出来而不用存储的时候，就能节省最大的空间。通过牺牲计算时间节省外在状态的存储空间。

---

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>代理</h3>

- **what** : 

  为其他对象提供一种代理以控制对这个对象的访问

- **how** ：

   使用一个基本上跟实体对象行为相同的代理，实现轻量级预处理。例如大开销的对象再收到请求之前不需要加载，则可通过虚拟代理向客户端提供某些轻量的信息，如图片、信息占位。

- **why** ：
  1. 需要一个远程代理（remote proxy）为位于不同地址空间或网络上的对象提供本地代表
  2. 需要一个虚拟代理（virtual proxy）根据需要创建重型对象
  3. 需要一个保护代理（protection proxy）根据各种访问权限控制对原对象的访问
  4. 需要一个智能引用代理（smart-reference proxy）通过对真正对象的引用进行计数来管理内存。也用于锁定真正对象，让其他对象不能对其进行修改

<br>

---

Tips:

​	Cocoa中的代理：OC不支持多重继承，如果代理对象不是Cocoa Touch框架中任何类的子类的话，可以考虑使用NSProxy作为占位或代替对象。

---

