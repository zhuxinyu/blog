<h1>第八部分 性能与访问对象</h1>

> 概要
>
> > - 享元 flyweight 
> > - 代理

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>享元</h3>

- **what** : 

  运用共享技术有效地支持大量细粒度的对象。

- **how** ：

  实现享元模式需要两个关键组件，通常是可共享的享元对象和保存他们的池。某种中央对象维护这个池，并从它返回适当的实例。(工厂是这一角色的理想候选)

- **why** ：

  1. 应用程序使用很多对象
  2. 在内存中保存对象会影响内存性能
  3. 对象的多数特有状态（外在状态）可以放到外部而轻量化
  4. 移除了外在状态之后，可以用较少的共享对象替代原来的那组对象
  5. 应用程序不依赖于对象标识，因为共享对象不能提供唯一的标识

<br>

---

Tips:

- 节省空间的影响因素：
   	1. 通过共享减少的对象总数，越多节省空间越大
   	2. 每个对象中内在状态（即可共享状态）的数量，越多越节省内在开销
   	3. 外在状态是计算出来的还是保存的，外在状态的传递、查找和计算，可能产生运行时的开销，尤其在外在状态原本是作为内在状态来保存的时候。如果有大量内在和外在状态，外在状态又能够计算出来而不用存储的时候，就能节省最大的空间。通过牺牲计算时间节省外在状态的存储空间。

---

<br>

