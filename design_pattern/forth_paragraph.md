<h1>第四部分 对象去耦</h1>

> 概要
>
> > - 中介者 mediator
> > - 观察者 observer

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>中介者</h3>

- **what** : 

  用一个对象来封装一系列对象的交互方式。中介者使得各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变他们之间的交互。

- **how** ：

  1. 通过父类控制子类实现
  2. 同级之间，由一个类来控制其他类

- **why** ：
  1. 对象间的交互虽然定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解
  2. 因为对象引用了许多其他对象并与其通信，导致对象难以复用
  3. 想要定制一个分步在多个类中的逻辑或行为，又不想生成太多子类

<br>

---

Tips

​	定义对象的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

---

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>观察者</h3>

- **what** : 

  定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

- **how** ：

  1. 通过通知实现主题与观察者的一种松耦合方式通信
  2. 基于NSKeyValueObserving非正式协议实现KVO

- **why** ：
  1. 有两种抽象类型相互依赖。将他们封装在各自的对象中，就可以对它们单独进行改变和复用。
  2. 对一个对象的改变同时需要改变其他对象，而不知道具体有多少对象待改变。
  3. 一个对象必须通知其他对象，而它又不许知道其他对象是什么。

<br>

---

Tips

​	

|                 通知                 |            键-值观察             |
| :----------------------------------: | :------------------------------: |
| 一个中心对象为所有观察者提供变更通知 | 被观察的对象直接向观察者发送通知 |
|       主要从广义上关注程序事件       |      绑定于特定对象属性的值      |

---

