<h1>第五部分 抽象集合</h1>

> 概要
>
> > - 组合 composite
> > - 迭代器 iterater

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>组合</h3>

- **what** : 

  将对象组合成树形结构以表示“部分-整体”的层次结构，组合使得用户对单个对象和组合对象的使用具有一致性。

- **how** ：

  1. 通过父类控制子类实现
  2. 同级之间，由一个类来控制其他类

- **why** ：

  1. 对象间的交互虽然定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解
  2. 因为对象引用了许多其他对象并与其通信，导致对象难以复用
  3. 想要定制一个分步在多个类中的逻辑或行为，又不想生成太多子类

<br>

<br>

<img src="https://github.com/zhuxinyu/blog/blob/master/logo.jpg" width = "30" height = "30" div align=left /><h3>迭代器</h3>

- **what** : 

  提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。（主体思想：枚举）

- **how** ：

  1. Block遍历方法 enumerateobjectUsingBlock:(void (^)(id obj, NSUInteger idx, BOOL *stop))block
  2. NSEnumberator
  3. 快速枚举 for ... in ...
  4. NSArray 内部枚举 (void) makeObjectsPerformSelector:(SEL)aSelector

- **why** ：

  1. 需要访问组合对象的内容， 而又不暴露其内部表示
  2. 需要通过多种方式遍历组合对象
  3. 需要提供一个统一的接口，用来遍历各种类型的组合对象

<br>

---

Tips

​	

|                          外部迭代器                          |                          内部迭代器                          |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 客户端需要知道外部迭代器才能使用，但是它为客户端提供了更多的控制 | 客户端不需要知道任何外部迭代器，而是可以通过集合对象的特殊接口，或者一次访问一个元素，或者向集合中的每个元素发送消息 |
|                  客户端创建并维护外部迭代器                  |             集合对象本身创建并维护它的外部迭代器             |
|           客户端可以使用不同外部迭代器实现多种遍历           | 集合对象可以在不修改客户端代码的情况下，选择不同的外部迭代器 |

- 风险：在遍历时修改聚合对象为保证数据正确最简单的办法是对聚合对象进行deep copy,然后遍历副本，但deep copy可能影响性能，代价较大
-  有很多方法可以实现不受元素插入与删除影响的迭代器。大部分依靠向聚合体注册迭代器。一种实现方法是在插入与删除操作时，聚合体或者调整由它生成的迭代器的内部状态，或者在内部维护信息，以确保正确的遍历。
- **设计模式之间的关系：
   	1. 组合模式通常依靠迭代器来遍历其递归结构。
   	2. 多态的迭代器依靠工厂方法来实例化适当的迭代器具体子类。
   	3. 迭代器可以使用备忘录来截取迭代的状态。迭代器在内部保存备忘录，在以后从它恢复其内部状态。

---

